<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Game of life</title>
    </head>
    <body>
        Ctrl + Mouse move : create live cells </br>
        Alt + Mouse move : remove live cells </br>  
        <canvas id="canvas" width="1500" height="800" style="border:1px solid #d3d3d3;">
            Your browsser does not support the HTML5 canvas tag.
        </canvas>

        <div id="info">
            <span>Generation: </span><span id="generation">0</span>
        </div>

        <div id="buttons">
            <input type="button" id="start" value="Start">
            <input type="button" id="stop" value="Stop">
            <input type="button" id="step" value="Next">
            <input type="button" id="reset" value="Reset">
            <input type="button" id="slower" value="Slower">
            <input type="button" id="faster" value="Faster">
        </div>
        <script>
            const colorLightGray = "#D3D3D3";
            const colorGreen = "#008000";
            const colorWhite = "#FFFFFF";

            var cellSize = 1;
            var columns = 1500;     // should be canvas height devided by cell size
            var rows = 800;         // should be canvas width devided by cell size    
            var width = cellSize*columns; 
            var height = cellSize*rows; 

            var canvas = document.getElementById("canvas");    
            var ctx = canvas.getContext("2d");

            var generation=0;
            var gen = document.getElementById("generation");    

            var interval = 100; // milliseconds
            var intervalId;
            
            var liveCells;
            var maxLiveCells = 0;

            //function Tuple(a,b) {
            //    this.first = a;
            //    this.second = b;
            //}

            function drawGrid() {
                ctx.strokeStyle = colorLightGray;
                //ctx.strokeStyle = colorWhite;
                for (let i = 0; i < width; i += cellSize) {
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, height);
                    ctx.stroke();
                }

                for (let i = 0; i < height; i += cellSize) {
                    ctx.moveTo(0, i);
                    ctx.lineTo(width, i);
                    ctx.stroke();
                }  
            }

            // fill cell at (i, j) with color
            function fillRect(i, j, color) {
                ctx.fillStyle = color;
                ctx.fillRect((i)*cellSize+1, (j)*cellSize+1, cellSize-2, cellSize-2);
                //ctx.fillRect((i)*cellSize, (j)*cellSize, cellSize, cellSize);                                        
                //ctx.fillRect(i, j, 1, 1); // improve performance: cellSize==1
            }

            function turnOn(i, j) {
                //fillRect(i, j, colorGreen); //--> inline                                        
                ctx.fillStyle = colorGreen;
                ctx.fillRect(i, j, 1, 1);
            }

            function turnOff(i, j) {
                //fillRect(i, j, colorWhite); //--> inline
                ctx.fillStyle = colorWhite;
                ctx.fillRect(i, j, 1, 1);
            }

            // create an array of size m x n, initialized with v
            function createArray(columns, rows, value) {
                ret = new Array(columns);

                for (let i = 0; i < columns; i++) {
                    ret[i] = new Array(rows).fill(value);
                }
                
                return ret;
            }

            // reset a 2D array
            function resetArray2D(array, value) {
                for (const e of array) {
                    e.fill(value);
                }
            }

            // currently not used, inline calculate to improve performance
            function coordToNumber(x, y) {
                return y * columns + x;
            }

            // currently not used, inline calculate to improve performance
            function numberToX(n) {
                return n % columns;
            }

            // currently not used, inline calculate to improve performance
            function numberToY(n) {
                return Math.floor(n / columns);
            }
                                
            function normalizeX(x) {
                if (x<0) return x+columns;
                if (x>columns-1) return 0;
                return x;
            }
            
            function normalizeY(y)
            {
                if (y<0) return y+rows;
                if (y>rows-1) return 0;
                return y;
            }

            //cell and its neighbor coordinates
            //[x-1][y-1] [x][y-1] [x+1][y-1] 
            //[x-1][y]   [x][y]   [x+1][y] 
            //[x-1][y+1] [x][y+1] [x+1][y+1] 
            // update neighbor count of a given cell (x, y)
            // if (x, y) is not inside the grid, the coordinates are
            // normalized so that another cell at the other side of 
            // the grid is updated.
            // v is the delta to update neighbor count:
            // v=1 to increment neighbor count
            // v=-1 to decrease neighbor count                        
            function updateNeighbors(x, y, v) {
                let X           = normalizeX(x);
                let X_plus_1    = normalizeX(x+1);
                let X_minus_1   = normalizeX(x-1);
                let Y           = normalizeY(y);
                let Y_plus_1    = normalizeY(y+1);
                let Y_minus_1   = normalizeY(y-1);
                                                       
                neighborCount[X_minus_1][Y_minus_1]+=v;
                neighborCount[X        ][Y_minus_1]+=v;
                neighborCount[X_plus_1 ][Y_minus_1]+=v;
                neighborCount[X_minus_1][Y        ]+=v;
                neighborCount[X_plus_1 ][Y        ]+=v;
                neighborCount[X_minus_1][Y_plus_1 ]+=v;
                neighborCount[X        ][Y_plus_1 ]+=v;
                neighborCount[X_plus_1 ][Y_plus_1 ]+=v;
            }

            // increase neighbor count of surrounding cells when adding new live cells
            function incNeighborCount (x, y) {            
                updateNeighbors(x, y, 1);
            }    

            // decrease neighbor count of surrounding cells when removing a dead cell
            function decNeighborCount (x, y) {
                updateNeighbors(x, y, -1);
            }    


            // set cell (x, y) a live cell
            function setLiveCell(x, y) {
                if (occupations[x][y] != 1) {
                    liveCells.set(y * columns + x, 1);
                    occupations[x][y] = 1;
                    incNeighborCount(x, y);        
                    turnOn(x, y);
                }
            }    

            // set cell (x, y) as dead cell
            function setDeadCell(x, y) {
                occupations[x][y] = 0;
                liveCells.delete(y * columns + x);
                decNeighborCount(x,y);
                turnOff(x, y);
            }

            // check if a given dead cell becomes a live cell
            function checkForNewLiveCell(x, y) {
                if ((occupations[x][y]==0) && (neighborCount[x][y]==3)) {
                    occupations[x][y]=-1; // special flag to mark this cell becoming live, dont check again
                    // newLiveCells.push(new Tuple(x, y));
                    newLiveCells.push({ x, y});
                }
            }

            // 1. Any live cell with two or three neighbors survives.
            // 2. Any dead cell with three live neighbors becomes a live cell.
            // 3. All other live cells die in the next generation. Similarly, all other dead cells stay dead.
            function update() {
                newLiveCells = [];
                newDeadCells = [];

                if (liveCells.size > maxLiveCells) {
                    maxLiveCells = liveCells.size;
                    if (maxLiveCells > 10000)
                        console.log("Max: " + maxLiveCells);
                }                                       
                
                // collect an array of new live cells from neighbors of the current 
                // live cells, because new live cells do not just come from nothing
                liveCells.forEach((value, key)=>{
                    var x = key % columns;              // numberToX(key);
                    var y = Math.floor(key / columns);  // numberToY(key);

                    let X           = normalizeX(x);
                    let X_plus_1    = normalizeX(x+1);
                    let X_minus_1   = normalizeX(x-1);
                    let Y           = normalizeY(y);
                    let Y_plus_1    = normalizeY(y+1);
                    let Y_minus_1   = normalizeY(y-1);
                                                           
                    checkForNewLiveCell(X_minus_1, Y_minus_1);
                    checkForNewLiveCell(X        , Y_minus_1);
                    checkForNewLiveCell(X_plus_1 , Y_minus_1);
                    checkForNewLiveCell(X_minus_1, Y        );
                    checkForNewLiveCell(X_plus_1 , Y        );
                    checkForNewLiveCell(X_minus_1, Y_plus_1 );
                    checkForNewLiveCell(X        , Y_plus_1 );
                    checkForNewLiveCell(X_plus_1 , Y_plus_1 );
                    
                    if ((neighborCount[x][y] < 2) || (neighborCount[x][y] > 3))
                        // newDeadCells.push (new Tuple(x, y));
                        newDeadCells.push ({ x, y});
                });

                // remove new dead cells
                for (const e of newDeadCells) {
                    //setDeadCell(e.first, e.second);            
                    setDeadCell(e.x, e.y);            
                }

                // create new live cells
                for (const e of newLiveCells) {
                    //setLiveCell(e.first, e.second);
                    setLiveCell(e.x, e.y);
                }

                generation += 1;
                gen.innerText=generation;                                       
            }

            // stop timer
            function stop() {
                window.clearInterval(intervalId);
            }

            // start timer
            function start() {
                stop();
                intervalId = window.setInterval(update, interval);
            }

            // test
            function test() {
                for (let i = 1; i < columns-15; i+= 15) {
                    for (let j = 1; j < rows-25; j+= 25) {
                        pattern_glider(i, j);
                    }
                }
            }

            // get relative mouse position
            function getMousePos(canvas, evt) {
                var rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }

            // get cell coordinate
            function getCellCoord(pos) {
                return {
                    x : Math.floor(pos.x / cellSize),
                    y : Math.floor(pos.y / cellSize)
                }
            }

            // mouse event handling
            function initMouseHandler() {
                // while moving mouse hold Control to initialize live cells
                // or hold Shift to uninitialize live cells
                canvas.addEventListener('mousemove', function(evt) {
                        if (evt.ctrlKey) {
                            let mouseCoord = getCellCoord(getMousePos(canvas, evt));
                            setLiveCell(mouseCoord.x, mouseCoord.y);    
                        }
                        if (evt.altKey) {
                            let mouseCoord = getCellCoord(getMousePos(canvas, evt));
                            setDeadCell(mouseCoord.x, mouseCoord.y);    
                        }            
                    }, false);
            }

            // create next generation
            function step() {
                stop();
                update();
            }

            // reset everything
            function reset() {
                stop();     
                liveCells.forEach((value, key)=>{
                    var x = key % columns;              // numberToX(key);
                    var y = Math.floor(key / columns);  // numberToY(key);
                    setDeadCell(x, y);
                });
                resetArray2D(neighborCount, 0);
                resetArray2D(occupations, 0);
                
                generation=0;
                update();                                         
            }

            // change speed by a number of milliseconds
            function changeSpeed(ms) {
                stop();
                interval += ms;
                console.log("Speed(ms): " + interval);
                start();
            }

            function slower() {
                changeSpeed(10);        
            }

            function faster() {
                if (interval >= 20)
                    changeSpeed(-10);
            }

            function init_random() {
                for (let i = 0; i < 100; i++) {
                    pattern_glider(Math.floor(Math.random()*columns), Math.floor(Math.random()*rows))
                }
            }
            
            // create a glider pattern at (x, y)
            function pattern_glider(x, y) {
                stop();

                setLiveCell(x  , y  );
                setLiveCell(x+1, y+1);
                setLiveCell(x+2, y+1);
                setLiveCell(x  , y+2);
                setLiveCell(x+1, y+2);

                start();
            }
                        
            function read_pattern(x0, y0, w0, h0, pattern) {
            
                reset();

                let tokens = pattern.split(/([b,o,$,!])/).filter(token => token.length > 0 && token != '!')                            
                
                let x = x0; // upper left x
                let y = y0; // upper left y
                let count = 1;

                console.log(tokens);

                function skip(count) {
                    if (x + count >= x0 + w0) { // exceeds end of line
                        x = x0 + ((x - x0 + count) % w0);
                        y = y + 1;
                    } else {
                        x += count;
                    }
                }

                function setLiveCells(count) {
                    for (let i = 0; i < count; i++) {
                        setLiveCell(x, y);
                        skip(1);
                    }
                }

                for (let i = 0; i < tokens.length; i++) {    
                    switch (tokens[i]) {
                        case 'b': // dead cell
                            skip(count);
                            count = 1;
                            break;
                        case 'o': // live cell
                            setLiveCells(count);
                            count = 1;
                            break;
                        case '$': // end of line
                            if (x > x0) {
                                skip(x0 + w0 - x);
                            }
                            while (count > 1) { // empty lines
                                skip(w0);
                                count--;
                            }
                            break;
                        default: // count
                            count = parseInt(tokens[i]);
                    }
                }                        
                
                start();
            }

            //drawGrid();
            
            neighborCount = createArray(columns, rows, 0);
            occupations = createArray(columns, rows, 0);    
            liveCells = new Map();

            initMouseHandler();

            // bind event handlers to buttons
            document.getElementById('start').addEventListener('click', start, false);    
            document.getElementById('stop').addEventListener('click', stop, false);    
            document.getElementById('step').addEventListener('click', step, false);
            document.getElementById('reset').addEventListener('click', reset, false);
            document.getElementById('slower').addEventListener('click', slower, false);
            document.getElementById('faster').addEventListener('click', faster, false);

            //TODO
            // 2. Buttons for predefined patterns
            // 5. Save initial pattern (experimenting purposes)
        </script>

    </body>
</html>
